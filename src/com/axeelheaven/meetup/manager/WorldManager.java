package com.axeelheaven.meetup.manager;

import java.io.*;
import java.util.*;

import org.bukkit.*;
import org.bukkit.block.Block;
import org.bukkit.block.BlockFace;
import org.bukkit.entity.*;
import org.bukkit.scheduler.*;

import com.axeelheaven.meetup.*;
import com.axeelheaven.meetup.enums.*;
import com.axeelheaven.meetup.task.*;
import com.axeelheaven.meetup.util.*;
import com.axeelheaven.meetup.worldborder.LoadChunks;

public class WorldManager {
	
	private Main plugin;
    private Set<Material> passThroughMaterials = new HashSet<>();
	
	public WorldManager(final Main plugin) {
		this.plugin = plugin;
		if(plugin.getCache().getBoolean("world.is_loader")) {
			this.createWorld(false);
			this.plugin.getGameManager().setGameState(GameState.WAITTING);
			this.plugin.getCache().set("world.is_loader", Boolean.valueOf(false));
			FileConfig.getInstance().save("cache.yml");
			Bukkit.getConsoleSender().sendMessage("§aThe world has been charged with success.");
			new GlassRunnable(plugin).start();
			for(final Entity entity : Bukkit.getWorld("Meetup").getEntities()) {
				if(!entity.getType().equals(EntityType.HORSE)) {
					entity.remove();
				}
			}
		} else {
			this.load();
		}
        this.passThroughMaterials.add(Material.LOG);
        this.passThroughMaterials.add(Material.LOG_2);
        this.passThroughMaterials.add(Material.LEAVES);
        this.passThroughMaterials.add(Material.LOG_2);
        this.passThroughMaterials.add(Material.AIR);
	}
	
	private void load() {
		this.plugin.getGameManager().setGameState(GameState.LOADING);
		if(Bukkit.getWorld("Meetup") != null){
    		Bukkit.getServer().unloadWorld("Meetup", false);
    	}
		this.deleteWorld(new File("Meetup"));
		new BukkitRunnable() {
			@Override
			public void run() {
				createWorld(true);
			}
		}.runTask(this.plugin);
	}
	
	public void createWorld(final boolean startup) {
		if(startup) {
			final File file = new File("Meetup");
			if(file.exists() && file != null) {
				this.load();
			} else {
				
				final WorldCreator wc = new WorldCreator("Meetup");
		        wc.environment(World.Environment.NORMAL);
			    long mapSeed = new Random().nextLong();
			    wc.seed(mapSeed);
			    wc.generateStructures(false);
			    wc.createWorld();
			    
			    final World world = Bukkit.getWorld("Meetup");
			    world.setAutoSave(false);
			    world.setGameRuleValue("naturalRegeneration", "false");
			    world.setGameRuleValue("doMobSpawning", "true");
				world.setGameRuleValue("doDaylightCycle", "false");
				world.setGameRuleValue("mobGriefing", "false");
				world.setGameRuleValue("commandBlockOutput", "false");
				world.setGameRuleValue("doFireTick", "false");
			    world.setPVP(true);
			    world.setDifficulty(Difficulty.HARD);
			    world.setTime(0L);
			    this.checkWorld(world);
			}
		} else {
			Bukkit.createWorld(new WorldCreator("Meetup").seed(plugin.getCache().getLong("world.seed")));
		}
	}
	
	private void checkWorld(final World world) {
		int log = 0;
		int waters = 0;
		final int worldsize = this.plugin.getGameManager().getBorder();
		
        for (Block b : new Cuboid(new Location(world, worldsize, 81.0D, worldsize), new Location(world, -worldsize, 55.0D, -worldsize))){
        	if (b.getType().equals(Material.LOG) || b.getType().equals(Material.LOG_2)) {
        		log = log + 1;
        	}
        	if (b.getType().equals(Material.WATER) || b.getType().equals(Material.STATIONARY_WATER) || 
        			b.getType().equals(Material.LAVA) || b.getType().equals(Material.STATIONARY_LAVA)) {
        		waters = waters + 1;
        	}
        }
        if(log >= this.plugin.getConfig().getInt("world_settings.verific.maxLog")){
        	Bukkit.broadcastMessage("§fThe world could not be generated by §cExcesive Trees§7(" + log + "§7)");
        	this.load();
        } else if(waters >= this.plugin.getConfig().getInt("world_settings.verific.maxWater")){
        	Bukkit.broadcastMessage("§fThe world could not be generated by §cExcesive Water/Lava§7(" + waters + "§7)");
        	this.load();
        } else {
    	    Bukkit.getConsoleSender().sendMessage("The world has been successfully created");
        	this.loadChunks();
        }
	}
	
	private void addBedrockBorder(final int radius) {
        new BukkitRunnable() {

            private int counter = -radius - 1;
            private boolean phase1 = false;
            private boolean phase2 = false;
            private boolean phase3 = false;

            @Override
            public void run() {
                if (!phase1) {
                    int maxCounter = counter + 500;
                    int x = -radius - 1;
                    for (int z = counter; z <= radius && counter <= maxCounter; z++, counter++) {
                        figureOutBlockToMakeBedrock(x, z);
                    }

                    if (counter >= radius) {
                        counter = -radius - 1;
                        phase1 = true;
                    }

                    return;
                }

                if (!phase2) {
                    int maxCounter = counter + 500;
                    int x = radius;
                    for (int z = counter; z <= radius && counter <= maxCounter; z++, counter++) {
                        figureOutBlockToMakeBedrock(x, z);
                    }

                    if (counter >= radius) {
                        counter = -radius - 1;
                        phase2 = true;
                    }

                    return;
                }

                if (!phase3) {
                    int maxCounter = counter + 500;
                    int z = -radius - 1;
                    for (int x = counter; x <= radius && counter <= maxCounter; x++, counter++) {
                        if (x == radius || x == -radius - 1) {
                            continue;
                        }

                        figureOutBlockToMakeBedrock(x, z);
                    }

                    if (counter >= radius) {
                        counter = -radius - 1;
                        phase3 = true;
                    }

                    return;
                }


                int maxCounter = counter + 500;
                int z = radius;
                for (int x = counter; x <= radius && counter <= maxCounter; x++, counter++) {
                    if (x == radius || x == -radius - 1) {
                        continue;
                    }

                    figureOutBlockToMakeBedrock(x, z);
                }

                if (counter >= radius) {
                    this.cancel();
                }
            }
        }.runTaskTimer(this.plugin, 0, 5);
    }

    private void figureOutBlockToMakeBedrock(int x, int z) {
        Block block = this.plugin.getServer().getWorld("Meetup").getHighestBlockAt(x, z);
        Block below = block.getRelative(BlockFace.DOWN);
        while (passThroughMaterials.contains(below.getType()) && below.getY() > 1) {
            below = below.getRelative(BlockFace.DOWN);
        }

        below.getRelative(BlockFace.UP).setType(Material.BEDROCK);
    }

    private void addBedrockBorder(final int radius, int blocksHigh) {
        for (int i = 0; i < blocksHigh; i++) {
            new BukkitRunnable() {
                public void run() {
                    addBedrockBorder(radius);
                }
            }.runTaskLater(this.plugin, i);
        }
    }
	
	private void loadChunks(){
		for(Player p : Bukkit.getOnlinePlayers()) {
			p.kickPlayer("Loading chunks.");
		}
		new LoadChunks(this.plugin);
	}
	
	public boolean deleteWorld(final File path) {
		if(path.exists()) {
			File files[] = path.listFiles();
			for(int i=0; i<files.length; i++) {
				if(files[i].isDirectory()) {
					deleteWorld(files[i]);
				}else{
					files[i].delete();
				}
			}
		}
		return(path.delete());
	}
	
}
